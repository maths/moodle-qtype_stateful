{
  "name": "TECH: Answer-tests in Stateful",
  "description": "This question is a technical demonstrator and tester for the answer-tests present in Stateful. You may use it to browse and try the available tests and see if the declared unit-tests for the tests still work.\n\nNote, that this demonstrator uses custom validation messages to show how one could call the same test outside PRTs, but those messages cannot include the feedback generated by the tests. Should you wish to see the feedback you will need to press the check button to see it.\n\nNote 2, the 'no-units' option of inputs is used as this material contains both units and test cases that don't like units. As this material has units it means that all validation would by default expect units and give feedback about things like 'a' vs. 'A'.",
  "modelsolution": "",
  "questionnote": "",
  "pointvalue": 1,
  "penalty": 0.3333333,
  "parlength": -1,
  "questionvariables": "",
  "statevariables": [],
  "scenes": [
    {
      "name": "entry",
      "description": "Initial scene for a Stateful-question, no question can exists without a scene.",
      "scenevariables": "",
      "scenetext": "<h3>Stateful answer-test demonstrator</h3>\n<p>The actual tests have been separated to scenes due to the fact that this material also contains tests for those tests and collecting everything into a single scene would make things annoying to update. Please select (and then check) the test you wish to look into, you can return to this list and the test will be described in more detail in its own scene:</p>\n\n[[input:tests]]\n\n[[ if test=\"false\"]]To keep that one warning quiet: [[feedback:select]] [[validation:tests]] [[/if]]",
      "inputs": [
        {
          "name": "tests",
          "tans": "\"AlgEquiv\"",
          "type": "mcq",
          "mcq-options": [
            {
              "value": "\"Diff\"",
              "label": "<h4>Calculus</h4>\n<p><i>Diff</i>-test checks if the answer is the derivate of something and gives related feedback if it is something else.</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"Int\"",
              "label": "<p><i>Int</i>-test checks if the integral of something and will provide related feedback, can be configured to note the existence of integration constants.</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"AlgEquiv\"",
              "label": "<h4>Equality</h4>\n<p><i>Algebraic-equivalence</i> the primary test\nusable for pretty much everything.</p>",
              "group": "correct"
            },
            {
              "value": "\"CasEqual\"",
              "label": "<p><i>CAS-equality</i> slightly different \ntake on equality.</p>",
              "group": "distractor"
            },
            {
              "value": "\"SubstEquiv\"",
              "label": "<p><i>Substitution-equivalence</i>, checks if simply swithing some variables the answer would be equal to the teachers answer.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"SameType\"",
              "label": "<p><i>Type-equivalence</i> tests if a list is a list or for example if something is an inequality, just checks if the object is of the same type, does not care about values. </p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"EqualComAss\"",
              "label": "<p><i>Commutative and associative equality</i> tests if the answers terms could be rearranged repecting commutativity and associativity so that the the expression would match the teachers answer. Best suitted for checking steps of work and skipping the simplification when checking.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"Sets\"",
              "label": "<p><i>Set-comparison</i> specific feedback about differrences of sets.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"LowestTerms\"",
              "label": "<h4>Form</h4><p><i>Simplified fractions</i>-test checks if all the fractions in the answer are fully simplified and representted with the lowest possible terms.</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"Expanded\"",
              "label": "<p><i>Expanded-form</i> tests if an expression has been fully expanded.</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"FacForm\"",
              "label": "<p><i>Factored-form</i> tests if an expression has been fully factored.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"SingleFrac\"",
              "label": "<p><i>Single fraction-form</i> checks that the answer is equivalne and representted as a single fraction.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"PartFrac\"",
              "label": "<p><i>Partial-fraction-form</i> checks if the answer is equivalent and presentted as a partial-fraction decomposition.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"CompSquare\"",
              "label": "<p><i>Completed square-form</i> checks the form and equality.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"GT & GTE\"",
              "label": "<h4>Inequality</h4><p><i>Numerical larger than or equal tests</i> do what they say with equality or not.</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"ATNumerical\"",
              "label": "<h4>Numerical</h4><p><i>Absolute- and relative-tolerance numerical testing</i></p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"StrictSigFigs\"",
              "label": "<p><i>Strict significant-figures</i> a variant that enforces a stricter interpretation of significant-figures.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"NumSigFigs\"",
              "label": "<p><i>Significant-figures</i>\nnumerical value testing with representational requirements.\n</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"NumDecPlaces\"",
              "label": "<p><i>Decimal-places</i> should one wish to check that the answer has a given number of decimal places and is accurate to that level.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"DecimalPlacesWrong\"",
              "label": "<p><i>Missplaced decimal separator</i> should one wish to check if the answer is just multiplie by arbitrary power of ten, but still matches for a given number of most-significant digits.</p><b>NOT YET PRESENT IN THIS TEST SET</b>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"Strings\"",
              "label": "<h4>Strings</h4><p><i>ATSRegExp</i>, <i>StringContains</i> and <i>StringContainsIC</i>\nfor when one needs to fall back to <code>\"string\"</code>-matching. Don't use these.\n</p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"UnitsSigFigs\"",
              "label": "<h4>Units</h4><p><i>Unit-conversion avare test with sig-figs checks.</i></p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"UnitsStrictSigFigs\"",
              "label": "<p><i>Unit-conversion forbidding test with sig-figs checks.</i></p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"ATUnitsFun\"",
              "label": "<p>Absolute- and relative-tolerance tests with units. With or without unit conversions.</p>",
              "group": "distractor",
              "inclusion": "true"
            }
          ],
          "mcq-no-deselect": true,
          "forbid-floats": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false
        }
      ],
      "vboxes": [],
      "prts": [
        {
          "name": "select",
          "feedbackvariables": "/* Note, that in this PRT one could just write the value directly\n * to SCENE_NEXT and be done with it, but as this sample material\n * is expected to be explored by users not necessary seeing why\n * that is not something one would want to do we intenttionally do \n * not do so. Therefore we have this ugly list-like PRT instead of \n * just one node and a line of code.\n *\n * Do not write to SCENE_NEXT before you \"grok in fullness\" what it \n * means. Why it is possible yet still not recommended is something\n * beyond this note.\n */",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"AlgEquiv\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "TODO",
                "variables": "",
                "next": "$SCENE:AlgEquiv",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "AlgEquiv",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"AlgEquiv\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "TODO",
                "variables": "",
                "next": "NumSigFigs",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "NumSigFigs",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"NumSigFigs\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "TODO",
                "variables": "",
                "next": "$SCENE:NumSigFigs",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "NumSigFigs",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"NumSigFigs\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "TODO",
                "variables": "",
                "next": "Strings",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Strings",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"Strings\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:Strings",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Strings",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"Strings\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "CasEqual",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "CasEqual",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"CasEqual\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:CasEqual",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "CasEqual",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"CasEqual\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "Diff",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Diff",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"Diff\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:Diff",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Diff",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"Diff\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "Int",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Int",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"Int\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:Int",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Int",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"Int\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "UnitsSigFigs",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "UnitsSigFigs",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"UnitsSigFigs\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:UnitsSigFigs",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "UnitsSigFigs",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"UnitsSigFigs\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "ATNumerical",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "ATNumerical",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"ATNumerical\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:ATNumerical",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "ATNumerical",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"ATNumerical\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "UnitsStrictSigFigs",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "UnitsStrictSigFigs",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"UnitsStrictSigFigs\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:UnitsStrictSigFigs",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "UnitsStrictSigFigs",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"UnitsStrictSigFigs\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "ATUnitsFun",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "ATUnitsFun",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"ATUnitsFun\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:ATUnitsFun",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "ATUnitsFun",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"ATUnitsFun\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "LowestTerms",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "LowestTerms",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"LowestTerms\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:LowestTerms",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "LowestTerms",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"LowestTerms\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "GT & GTE",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "GT & GTE",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"GT & GTE\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:ATGT(E)",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "ATGT(E)",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"GT & GTE\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "Expanded",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Expanded",
              "test": "AlgEquiv",
              "sans": "tests",
              "tans": "\"Expanded\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:Expanded",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Expanded",
                    "condition": "true",
                    "inputs": {
                      "tests": "\"Expanded\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        }
      ]
    },
    {
      "name": "AlgEquiv",
      "description": "All about ATAlgEquiv.",
      "scenevariables": "",
      "scenetext": "<h3><code>ATAlgEquiv(sans,tans)</code></h3>\n<p>The primary function of the algebraic-equivalence test is to check if one can simplify the difference of teachers and students answer to zero. In general this will work although special care must be taken if the answers contain trigonometric-functions, fractional-powers and/or logarithms, in those cases additional simplification steps may be necessary.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code> and <code>tans</code> and see what happens.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>This test has no optios beyond the quiet-switch.</p>\n\n<h4>Generated feedback</h4>\n<p>This test will complain if the answers type differs from the expected and in cases where the answer has structure like lists, sets, and matrices it may specify which elements do not match. This kind of feedback may prove to be inconvenient so do remember the existence of the quiet-switch.</p>\n\n<p>It is worth noting that the feedback can be quite specific when dealing with for example equalities so do check if this test already provides the feedback you need.</p>\n\n<h4>Classification notes</h4>\n<p>This test will provide plenty of notes about how the answer differs for later statistical analysis, here are some examples, click the samples to see them in action.</p>\n\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th><th>Sample(s)</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATList_wronglen</b></td><td>When comparing lists differing length is specifically noted.</td><td><code class=\"sample\" data-tans=\"[1]\" data-sans=\"[1,2,3]\">[1,2,3] != [1]</code></td></tr>\n<tr><td><b>ATList_wrongentries</b></td><td>When comparing lists of the same length the differing elements are noted.</td><td><code class=\"sample\" data-tans=\"[1,4,5]\" data-sans=\"[1,2,3]\">[1,2,3] != [1,4,5]</code></td></tr>\n<tr><td><b>ATSet_wrongsz</b></td><td>When comparing set differing size is specifically noted.</td><td><code class=\"sample\" data-tans=\"{1}\" data-sans=\"{1,2,3}\">{1,2,3} != {1}</code></td></tr>\n<tr><td><b>ATSet_wrongentries</b></td><td>When comparing set of the same size the differing elements are noted.</td><td><code class=\"sample\" data-tans=\"{1,4,5}\" data-sans=\"{1,2,3}\">{1,2,3} != {1,4,5}</code></td></tr>\n<tr><td><b>ATAlgEquiv_WrongCase</b></td><td>When the answers have case-differences in variables.</td><td><code class=\"sample\" data-tans=\"x\" data-sans=\"X\">X != x</code></td></tr>\n<tr><td><b>ATAlgEquiv_SA_not_list</b></td><td>When expecting a list but receiving something else.</td><td><code class=\"sample\" data-tans=\"[1]\" data-sans=\"1\">1 != [1]</code></td></tr>\n<tr><td><b>ATAlgEquiv_SA_not_set</b></td><td>When expecting a set but receiving something else.</td><td><code class=\"sample\" data-tans=\"{1}\" data-sans=\"1\">1 != {1}</code></td></tr>\n\n\n</tbody>\n</table>\n<p>TODO: all other notes...</p>\n\n\n[[jsxgraph input-ref-anst='anst' input-ref-anss='anss' height='1px']]\n/* JSXGraph blocks allow direct JavaScript access that can be used\n * to do many things, just set the size of the div reserved for the \n * graph that you are not actually building. Or hide it.\n */\n\nvar samples = $('code.sample');\nsamples.on('click', function(e) {\n  // Not .data() as these may look like JSON.\n  var t = $(e.target).attr('data-tans');\n  var s = $(e.target).attr('data-sans');\n  var sans = $('#' + $.escapeSelector(anss));\n  var tans = $('#' + $.escapeSelector(anst));             \n  sans.val(s);\n  tans.val(t);\n  sans.trigger('change');\n  tans.trigger('change');\n  sans.trigger('input');\n  tans.trigger('input');\n});\n[[/jsxgraph]]\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1",
          "type": "algebraic",
          "guidance-label": "Students answer",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true,
          "no-units": true
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "guidance-label": "Teachers answer",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true,
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATAlgEquiv({#anss#},{#anst#})</code></p>\n\n[[ if test=\"%_valid_anss and %_valid_anst\" ]]\n[[ define tr=\"ATAlgEquiv(anss,anst)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "The test",
          "nodes": [
            {
              "name": "The test",
              "test": "AlgEquiv",
              "sans": "anss",
              "tans": "anst",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1 = 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1",
                      "anst": "1"
                    }
                  },
                  {
                    "name": "[1] = [1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "[1]",
                      "anst": "[1]"
                    }
                  },
                  {
                    "name": "1=x =  x=1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1=x",
                      "anst": "x=1"
                    }
                  },
                  {
                    "name": "x<2 = 2>x",
                    "condition": "true",
                    "inputs": {
                      "anss": "x<2",
                      "anst": "2>x"
                    }
                  },
                  {
                    "name": "(1+x)*(1-x) = 1-x^2 ",
                    "condition": "true",
                    "inputs": {
                      "anss": "(1+x)*(1-x)",
                      "anst": "1-x^2"
                    }
                  },
                  {
                    "name": "cos(x+y) = cos(x)*cos(y)-sin(x)*sin(y)",
                    "condition": "true",
                    "inputs": {
                      "anss": "cos(x+y)",
                      "anst": "cos(x)*cos(y)-sin(x)*sin(y)"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1 != 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "1",
                      "anst": "2"
                    }
                  },
                  {
                    "name": "[2] != [1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "[2]",
                      "anst": "[1]"
                    }
                  },
                  {
                    "name": "x=2 != 1=x",
                    "condition": "true",
                    "inputs": {
                      "anss": "x=2",
                      "anst": "1=x"
                    }
                  },
                  {
                    "name": "x<2 != x<3",
                    "condition": "true",
                    "inputs": {
                      "anss": "x<2",
                      "anst": "x<3"
                    }
                  },
                  {
                    "name": "1-x^2 != x^2+1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1-x^2",
                      "anst": "1+x^2"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "NumSigFigs",
      "description": "All about NumSigFigs.",
      "scenevariables": "foo(a,b,c):=ATNumSigFigs_CASSigFigsWrapper(a,b,c,stackmap_get(_INPUT_STRING,\"anss\"));\nvalidoptions(opts):=ev(\n\tif integerp(opts) then (\n    \tif opts > 0 then true else false\n    ) else if listp(opts) then (\n    \tif length(opts) # 2 then false else (\n        \tif not apply(\"and\", map(integerp, opts)) then false else (\n            \tif opts[1] < 1 then false \n                else if opts[2] < -1 then false,\n                true\n            )\n        )\n    ) else false\n,simp);\n\n/* Provide variables */\nfour:4;\nthree:3;\ntwo:2;",
      "scenetext": "<h3><code>ATNumSigFigs(sans,tans,options)</code></h3>\n<p>A test for checking raw representation of a raw input-value. Only works with <code>sans</code> being a direct reference to an input. This test focuses on checking so called significant-figures. In general one can use this test to just check the existence on significant-figures or at the same time require that sufficient number of them equal to the expected value.</p>\n\n<p>The base-test does not use the strict significant-figures rules i.e. for this <code>100</code> has three significant-figures where for strict checks it would have less. If you need to test for the strict definition try the strict variant.</p>\n\n<p>The answer is expected to be numerical, so in this example the <code>sans</code>-input is a numerical-input. It is not recommended to use more complex input values here.</p>\n\n<p>Note that due to the direct connection to the raw input-value required by this test means that direct calling of this test is not something one can easily do. However, exploring the logic behind the validation message in this question may give a hint on how to do it.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code>, and <code>options</code> and see what happens. Note, for testing purposes the session has the following variables <code>four:4;three:3;two:2</code>, should you want to test certain behaviour.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]], <code>options:</code>[[input:ansoptions]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>This test relies heavily on options. One will need to define either one integer valued option or a list of two integers. The first case is equivalent of giving a list with two equal elements so lets focus on the list form as it is the one that matters:</p>\n<ol>\n<li>The first element (lets call it N) of the list describes how many significant-figures need to be present in the answer. In general one requires an exactly N significant-figures, should one need to allow more to be present then setting the second element to <code>-1</code> will make the test allow N or more. However, in that case all those N+ digits must be correct, to deal with that try setting the teachers asnwer to be the students answer.</li>\n<li>The second element (lets call it M) defines how many of the digits must match the teachers answer, typically one sets <code>M = N - 1</code> to allow some rounding errors in the last digit. Naturally, <code>M &lte; N</code> and both of them are integers.</li>\n</ol>\n\n<h4>Generated feedback</h4>\n<p>The test will give feedback about the number of digits and note about small or large accuracy issues. Depending on your use case you may wish to silence this test and construct your own feedback, using suitable combinations of this test with different options to identify the cases that matter to you.</p>\n\n<h4>Classification notes</h4>\n<p>This test will provide plenty of notes about how the answer differs for later statistical analysis, here are some examples, click the samples to see them in action.</p>\n\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th><th>Sample(s)</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATNumSigFigs_WrongDigits</b></td><td>Wrong number of digits.</td><td><code class=\"sample\" data-sans=\"0\" data-tans=\"0\" data-options=\"3\">0 != 0; 3</code></td></tr>\n<tr><td><b>ATNumSigFigs_Inaccurate</b></td><td>Slightly inaccurate.</td><td><code class=\"sample\" data-sans=\"10\" data-tans=\"11\" data-options=\"2\">10 != 11; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_VeryInaccurate</b></td><td>Very inaccurate.</td><td><code class=\"sample\" data-sans=\"100\" data-tans=\"11\" data-options=\"2\">100 != 11; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_WithinRange</b></td><td>Not quite \"strict\" significant-figures, but still accepted.</td><td><code class=\"sample\" data-sans=\"10\" data-tans=\"10\" data-options=\"2\">10 != 10; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_WrongSign</b></td><td>Sign error. Note may trigger if either value is zero.</td><td><code class=\"sample\" data-sans=\"-11\" data-tans=\"11\" data-options=\"2\">-11 != 11; 2</code></td></tr>\n\n\n</tbody>\n</table>\n\n\n[[jsxgraph input-ref-anst='anst' input-ref-anss='anss' input-ref-ansoptions='ansoptions'  height='1px']]\n/* JSXGraph blocks allow direct JavaScript access that can be used\n * to do many things, just set the size of the div reserved for the \n * graph that you are not actually building. Or hide it.\n */\n\nvar samples = $('code.sample');\nsamples.on('click', function(e) {\n  // Not .data() as these may look like JSON.\n  var t = $(e.target).attr('data-tans');\n  var s = $(e.target).attr('data-sans');\n  var o = $(e.target).attr('data-options');\n  var sans = $('#' + $.escapeSelector(anss));\n  var tans = $('#' + $.escapeSelector(anst));             \n  var options = $('#' + $.escapeSelector(ansoptions));\n  sans.val(s);\n  tans.val(t);\n  options.val(o);\n  sans.trigger('change');\n  tans.trigger('change');\n  options.trigger('change');\n  sans.trigger('input');\n  tans.trigger('input');\n  options.trigger('input');\n});\n[[/jsxgraph]]\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1",
          "type": "numerical",
          "guidance-label": "Students answer",
          "validation-box": "val"
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "guidance-label": "Teachers answer",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true,
          "no-units": true
        },
        {
          "name": "ansoptions",
          "tans": "[3,2]",
          "type": "algebraic",
          "guidance-label": "Test options",
          "allow-words": "four,three,two",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true,
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATNumSigFigs({#%_actual_anss#},{#anst#},{#ansoptions#})</code>. However, that would not give the full feedback this test generates.</p>\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_ansoptions and validoptions(ansoptions)\" ]]\n[[ define tr='foo(%_actual_anss,%_actual_anst,ansoptions)'/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "NumSigFigs",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Integer",
          "nodes": [
            {
              "name": "The test",
              "test": "NumSigFigs",
              "sans": "anss",
              "tans": "anst",
              "options": "ansoptions",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "3-figs  0.000 = 0; 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0,3)",
                      "anst": "0",
                      "ansoptions": "3"
                    }
                  },
                  {
                    "name": "Just 3-digs 0.123 = 0; [3,0]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.123,3)",
                      "anst": "0",
                      "ansoptions": "[3,0]"
                    }
                  },
                  {
                    "name": "Var-ref 0.1234 = 0.123; [four, four-1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.1234,4)",
                      "anst": "0.123",
                      "ansoptions": "RAW:[four, four-1]"
                    }
                  },
                  {
                    "name": "Excessive accuracy 1.10000 = 1.1; [3,-1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "RAW:1.10000",
                      "anst": "1.1",
                      "ansoptions": "[3,-1]"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "3-figs 0.001 != 0; 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.001,3)",
                      "anst": "0",
                      "ansoptions": "3"
                    }
                  },
                  {
                    "name": "Just 3-digs 0.12 != 0; [3,0]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.12,2)",
                      "anst": "0",
                      "ansoptions": "[3,0]"
                    }
                  },
                  {
                    "name": "Var-ref 0.12345 != 0; four",
                    "condition": "true",
                    "inputs": {
                      "anss": "0.12345",
                      "anst": "0",
                      "ansoptions": "RAW:four"
                    }
                  }
                ]
              }
            },
            {
              "name": "Integer",
              "test": "AlgEquiv",
              "sans": "integerp(ansoptions)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Large enough",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "List",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Large enough",
              "test": "AlgEquiv",
              "sans": "is(ansoptions>0)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "The test",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The option value msut be larger</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "List",
              "test": "AlgEquiv",
              "sans": "listp(ansoptions)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Two element list",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The option must either have an integer value or a list value.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Two element list",
              "test": "AlgEquiv",
              "sans": "length(ansoptions)",
              "tans": "2",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "First element positiveinteger",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The list must have exactly two elements.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "First element positiveinteger",
              "test": "AlgEquiv",
              "sans": "integerp(ansoptions[1]) and is(ansoptions[1]>0)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Second element integer",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The first element of the options list must be an positive integer.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Second element integer",
              "test": "AlgEquiv",
              "sans": "ev(integerp(ansoptions[2]) and is((ansoptions[2] + 2) > 0),simp)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "The test",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The second element of the options list must be an integer.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        }
      ]
    },
    {
      "name": "Strings",
      "description": "Tests acting on strings.",
      "scenevariables": "",
      "scenetext": "<h3><code>ATSRegExp(sans,tans)</code></h3>\n<p>This test tries to match a regular-expression patern (<code>tans</code>) to the input string (<code>sans</code>), using the maxima library <code>sregex</code>. As string processing is not a core STACK nor Stateful feature <b>these tests are not recommended</b> to be used but they exists for those cases where you absolutely must use them.</p>\n<p>These tests only work with <code>\"string\"</code>-values, so do not give them values that are not strings or direct references to inputs in which case the inputs raw value will be used.</p>\n<h4>What about <code>StringContains</code> and <code>StringContainsIC</code>?</h4>\n<p>There only exists a single test <code>ATSRegExp</code>, the tests <code>StringContains</code> and <code>StringContainsIC</code> are just convenience wrappers for it. The latter tests simply test if a given string is a substring of the answer with or without case-sensitivity, the convenience they provide is that they will automatically escape whatever regular-expression pattern related characters the string contains, thus avoiding the risk of failing to note such.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code> and <code>tans</code> and see what happens. Note that for your conveninece the inputs here are string-type inputs and you will not need to escape the values like normal Maxima-strings nor do you need to quote them.</p>\n\n<h5><code>ATSRegExp</code></h5>\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:sregexp]]</p>\n\n<h5><code>StringContains</code> and <code>StringContainsIC</code></h5>\n<p><code>sans:</code>[[input:anss2]], <code>tans:</code>[[input:anst2]]</p>\n<p>[[validation:val2]]</p>\n<p>[[feedback:contains]]</p>\n<p>[[feedback:containsic]]</p>\n\n\n\n<h4>Options</h4>\n<p>These tests have no optios beyond the quiet-switch, and even that does nothing.</p>\n\n<h4>Generated feedback</h4>\n<p>These tests do not generate feedback.</p>\n\n<h4>Classification notes</h4>\n<p>The tests will return a note where the match result from the internal <code>regex_match()</code>-call is present, one may use that for something. Especially, if the pattern contains capture-groups, which will then be present in the note.</p>\n\n\n\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "\"foo\"",
          "type": "string",
          "validation-box": "val"
        },
        {
          "name": "anst",
          "tans": "\"foo\"",
          "type": "string",
          "validation-box": "val"
        },
        {
          "name": "anss2",
          "tans": "\"foo\"",
          "type": "string",
          "validation-box": "val2"
        },
        {
          "name": "anst2",
          "tans": "\"foo\"",
          "type": "string",
          "validation-box": "val2"
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATSRegExp({#%_actual_anss#},{#%_actual_anst#})</code></p>\n\n[[ if test=\"%_valid_anss and %_valid_anst\" ]]\n[[ define tr=\"ATSRegExp(%_actual_anss,%_actual_anst)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        },
        {
          "name": "val2",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATSRegExp({#%_actual_anss2#},{#string_to_regex(%_actual_anst2)#})</code> or <code>ATSRegExp({#%_actual_anss2#},{#sconcat(\"(?i:\",string_to_regex(%_actual_anst2),\")\")#})</code></p>\n\n<h4><code>StringContains</code></h4>\n[[ if test=\"%_valid_anss2 and %_valid_anst2\" ]]\n[[ define tr=\"ATSRegExp(%_actual_anss2,ev(string_to_regex(%_actual_anst2),simp))\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]\n\n<h4><code>StringContainsIC</code></h4>\n[[ if test=\"%_valid_anss2 and %_valid_anst2\" ]]\n[[ define tr='ATSRegExp(%_actual_anss2,ev(sconcat(\"(?i:\",string_to_regex(%_actual_anst2),\")\"),simp))'/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "contains",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "StringContains",
              "sans": "anss2",
              "tans": "anst2",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<b>StringContains: PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Contains 1",
                    "condition": "true",
                    "inputs": {
                      "anss2": "\"foo bar baz\"",
                      "anst2": "\"bar\"",
                      "anss": "",
                      "anst": ""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>StringContains: FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Contains 2",
                    "condition": "true",
                    "inputs": {
                      "anss2": "\"foo bar baz\"",
                      "anst2": "\"BAR\"",
                      "anss": "",
                      "anst": ""
                    }
                  }
                ]
              }
            }
          ]
        },
        {
          "name": "containsic",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "StringContainsCI",
              "sans": "anss2",
              "tans": "anst2",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<b>StringContainsIC: PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Contains 1",
                    "condition": "true",
                    "inputs": {
                      "anss2": "\"foo Bar BAZ\"",
                      "anst2": "\"baz\"",
                      "anss": "",
                      "anst": ""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>StringContainsIC: FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "sregexp",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "StringRegExp",
              "sans": "anss",
              "tans": "anst",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Anchor 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "\"foo\"",
                      "anst": "\"^foo\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Anchor 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "\" foo\"",
                      "anst": "\"^foo\""
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "CasEqual",
      "description": "All about ATCasEqual",
      "scenevariables": "",
      "scenetext": "<h3><code>ATCasEqual(sans,tans)</code></h3>\n<p>The CAS-equality test is a bit odd creature as it essenttially tests if the expressions have the same structure without any simplification. You can use it distinguish between <code>1+1</code> and <code>2</code> but be very careful as for it even <code>x^(1/2)</code> and <code>sqrt(x)</code> are different.</p>\n<p>In most cases it is likely that you will instead want to use <code>ATEqualComAss</code> to allow some permutation of terms in the received expression as for <code>ATCasEqual</code> <code>1+2</code> is not equal to <code>2+1</code> but for <code>ATEqualComAss</code> it is.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code> and <code>tans</code> and see what happens.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>This test has no optios beyond the quiet-switch.</p>\n\n<h4>Generated feedback</h4>\n<p>The test does not generate any own feedback but it will let some through from <code>ATAlgEquiv</code> as it will try that to classify cases where CAS-equality is not true.</p>\n\n<h4>Classification notes</h4>\n<p>The notes are rather sparse, but follow the logic of the feedback and will include the notes from <code>ATAlgEquiv</code> if the test does not match.</p>\n<p>Expect to see <code>ATCASEqual_true</code> for cases where the tess passes and <code>ATCASEqual_false</code> for cases where <code>ATAlgEquiv</code> does not provide sensible notes. If <code>ATAlgEquiv</code> passes but this does not then <code>ATCASEqual (AlgEquiv-true)</code> is to be expected, otherwise it will appen the notes coming from <code>ATAlgEquiv</code> to <code>ATCASEqual </code>.</p>\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATCasEqual({#anss#},{#anst#})</code></p>\n\n[[ if test=\"%_valid_anss and %_valid_anst\" ]]\n[[ define tr=\"ATCasEqual(anss,anst)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "The test",
          "nodes": [
            {
              "name": "The test",
              "test": "CasEqual",
              "sans": "anss",
              "tans": "anst",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Direct match 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1+2",
                      "anst": "1+2"
                    }
                  },
                  {
                    "name": "Subscripts",
                    "condition": "true",
                    "inputs": {
                      "anss": "rho*z*V/(4*pi*epsilon[0]*(R^2+z^2)^(3/2))",
                      "anst": "rho*z*V/(4*pi*epsilon[0]*(R^2+z^2)^(3/2))"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Not ComAss 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1+2",
                      "anst": "2+1"
                    }
                  },
                  {
                    "name": "No simp",
                    "condition": "true",
                    "inputs": {
                      "anss": "2/4",
                      "anst": "1/2"
                    }
                  },
                  {
                    "name": "Basic trig 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "cos(x)",
                      "anst": "cos(-x)"
                    }
                  },
                  {
                    "name": "Basic trig 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "cos(x)^2+sin(x)^2",
                      "anst": "1"
                    }
                  },
                  {
                    "name": "No simp 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "x+x",
                      "anst": "2*x"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "Diff",
      "description": "ATDiff",
      "scenevariables": "",
      "scenetext": "<h3><code>ATDiff(sans,tans,option)</code></h3>\n<p>The differentiation-test just checks the equality of two statements, and should they differ we then check for more things. The primary feature is to check for the possibility of the student having integrated instead of differentiating and to give specific feedback should that happen. <i>In reality the more interesting calculus test is the integration-test but one can't always integrate.</i></p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code> and <code>option</code> and see what happens.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]] <code>option:</code>[[input:anso]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>The mandatory option in this test describes which variable was derived. That teachers answer is the result of that differenttiation. One can naturally quiet this test if one so wishes.</p>\n\n<h4>Generated feedback</h4>\n<p>There will be specific feedback if the student integrates. Also answering with an equation instead of an expression will be noted.</p>\n\n<h4>Classification notes</h4>\n<p>There are some notes that will be generated:</p>\n<table>\n<tr><td><code>ATDiff_true</code></td><td>When the test passes</td></tr>\n<tr><td><code>ATDiff_int</code></td><td>When the student integrated instead</td></tr>\n<tr><td><code>ATDiff_SA_not_expression</code></td><td>For wrong type of an answer</td></tr>\n<tr><td><code>ATDiff_var_SB_notSA</code></td><td>If the answer matches but somehow has the wrong variable</td></tr>\n<tr><td><code>ATDiff_var_notSASB_SAnceSB</code></td><td>When answer has some other variables and does not match at all</td></tr>\n\n</table>\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1",
          "type": "algebraic",
          "validation-box": "val",
          "forbid-floats": false,
          "no-units": true
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "validation-box": "val",
          "forbid-floats": false,
          "no-units": true
        },
        {
          "name": "anso",
          "tans": "x",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATDiff({#anss#},{#anst#},{#anso#})</code></p>\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_anso and symbolp(anso)\" ]]\n[[ define tr=\"ATDiff(anss,anst,anso)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "Diff",
              "sans": "anss",
              "tans": "anst",
              "options": "anso",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Basic 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^2",
                      "anst": "x^2",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Big 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "6000*(x-a)^5999",
                      "anst": "6000*(x-a)^5999",
                      "anso": "x"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Basic 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^2+1",
                      "anst": "x^2",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Big 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "5999*(x-a)^5999",
                      "anst": "6000*(x-a)^5999",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Int 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^4/4",
                      "anst": "3*x^2",
                      "anso": "x"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "Int",
      "description": "ATInt",
      "scenevariables": "check_opt(opt):=block([],\n if symbolp(opt) then return(true),\n if listp(opt) then (\n  if not symbolp(opt[1]) then return(false)\n ),\n return(false)\n);",
      "scenetext": "<h3><code>ATInt(sans,tans,options)</code></h3>\n<p>The integration-test does much more than the differentiation-test, it deals with the possibility of constant of integration beign freely chosen by the student and can be made to accept or comment answers that have no constant of integration.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code> and <code>options</code> and see what happens.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]] <code>options:</code>[[input:anso]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>Should your integrated teachers-answer be of a form that the test can esily derivate back to a sensible representation for us in its feedback and you wish to require that an integration-constant is present in the answer it is enough to just give the variable that was integrated on. Otrherwise, the options will need to be given as a list where that variable is the first element, the other elements may contain the original form of the expression that was integrated, and the keyword <code>NOCONST</code> which will then allow the answer to be accepted even without a constant.</p>\n\n\n<h4>Generated feedback</h4>\n<p>This test generates large amoutns of feedback. TODO: examples</p>\n\n<h4>Classification notes</h4>\n<p>There are some notes that will be generated:</p>\n<table>\n<tr><td><code>ATInt_true</code></td><td>When the test passes</td></tr>\n<tr><td><code>ATInt_const</code></td><td>If there is no constant present in the answer</td></tr>\n<tr><td><code>ATInt_const_int</code></td><td>There is no constant but there is something numerical extra instead.</td></tr>\n<tr><td><code>ATInt_weirdconst</code></td><td>The constant is nto a singular thing added to the expression or may be in parts</td></tr>\n<tr><td><code>ATInt_generic</code></td><td>When the answer does not match but there is no obvious reason</td></tr>\n<tr><td><code>ATInt_var_SB_notSA</code></td><td>When the expression could match but the variable is wrong</td></tr>\n<tr><td><code>ATInt_diff</code></td><td>The case of differenttiation.</td></tr>\n<tr><td><code>ATInt_true</code></td><td>When the test passes</td></tr>\n\n\n</table>\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "x+c",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "anso",
          "tans": "x",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATInt({#anss#},{#anst#},{#anso#})</code></p>\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_anso and check_opt(anso)\" ]]\n[[ define tr=\"ATInt(anss,anst,anso)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "Int",
              "sans": "anss",
              "tans": "anst",
              "options": "anso",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Basic 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^3/3+c",
                      "anst": "x^3/3",
                      "anso": "x"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Basic 2 requries const",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^3/3",
                      "anst": "x^3/3",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Basic 3 requires non integer const",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^3/3+1",
                      "anst": "x^3/3",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Basic 4 multiple const",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^3/3+c+k",
                      "anst": "x^3/3",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Basic 5 variable switch",
                    "condition": "true",
                    "inputs": {
                      "anss": "X^3/3+c",
                      "anst": "x^3/3",
                      "anso": "x"
                    }
                  },
                  {
                    "name": "Basic 6 diff & big",
                    "condition": "true",
                    "inputs": {
                      "anss": "6000*(x-a)^5999",
                      "anst": "(x-a)^6001/6001",
                      "anso": "x"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "UnitsSigFigs",
      "description": "All about UnitsSigFigs.",
      "scenevariables": "foo(a,b,c):=ATUnitsSigFigs_CASSigFigsWrapper(a,b,ev(c,simp),stackmap_get(_INPUT_STRING,\"anss\"),false);\nvalidoptions(opts):=ev(\n\tif integerp(opts) then (\n    \tif opts > 0 then true else false\n    ) else if listp(opts) then (\n    \tif length(opts) # 2 then false else (\n        \tif not apply(\"and\", map(integerp, opts)) then false else (\n            \tif opts[1] < 1 then false \n                else if opts[2] < -1 then false,\n                true\n            )\n        )\n    ) else false\n,simp);\n\n/* Provide variables */\nfour:4;\nthree:3;\ntwo:2;",
      "scenetext": "<h3><code>ATUnitsSigFigs(sans,tans,options)</code></h3>\n<p>A test for checking raw representation of a raw input-value. Only works with <code>sans</code> being a direct reference to an input. This test focuses on checking so called significant-figures. In general one can use this test to just check the existence on significant-figures or at the same time require that sufficient number of them equal to the expected value.</p>\n\n<p>This is essenttially the same test as the <code>ATNumSigFigs</code> however this test includes logic for convertting units and allows the student to use for example milli-meters when the teachers answer is in centi-meters. There is a \"strict\" variant of this test where the units need to match.</p>\n\n<p>The base-test does not use the strict significant-figures rules i.e. for this <code>100</code> has three significant-figures where for strict checks it would have less. There currently does not exist a strict significan-figures test for units.</p>\n\n<p>The answer is expected to be a number followed by the unit, so in this example the <code>sans</code>-input is a units-input. It is not recommended to use more complex input values here.</p>\n\n<p>Note that due to the direct connection to the raw input-value required by this test means that direct calling of this test is not something one can easily do. However, exploring the logic behind the validation message in this question may give a hint on how to do it.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code>, and <code>options</code> and see what happens. Note, for testing purposes the session has the following variables <code>four:4;three:3;two:2</code>, should you want to test certain behaviour.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]], <code>options:</code>[[input:ansoptions]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:UnitsSigFigs]]</p>\n\n<h4>Options</h4>\n<p>This test relies heavily on options. One will need to define either one integer valued option or a list of two integers. The first case is equivalent of giving a list with two equal elements so lets focus on the list form as it is the one that matters:</p>\n<ol>\n<li>The first element (lets call it N) of the list describes how many significant-figures need to be present in the answer. In general one requires an exactly N significant-figures, should one need to allow more to be present then setting the second element to <code>-1</code> will make the test allow N or more. However, in that case all those N+ digits must be correct, to deal with that try setting the teachers asnwer to be the students answer.</li>\n<li>The second element (lets call it M) defines how many of the digits must match the teachers answer, typically one sets <code>M = N - 1</code> to allow some rounding errors in the last digit. Naturally, <code>M &lte; N</code> and both of them are integers.</li>\n</ol>\n\n<h4>Generated feedback</h4>\n<p>The test will give feedback about the number of digits and note about small or large accuracy issues. Depending on your use case you may wish to silence this test and construct your own feedback, using suitable combinations of this test with different options to identify the cases that matter to you. The feedback will additionally note issues with wrong units.</p>\n\n<h4>Classification notes</h4>\n<p>This test will provide plenty of notes about how the answer differs for later statistical analysis, here are some examples, click the samples to see them in action. Most notes are inherited from the underlying <code>ATNumSigFigs.</code>.</p>\n\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th><th>Sample(s)</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATNumSigFigs_WrongDigits</b></td><td>Wrong number of digits.</td><td><code class=\"sample\" data-sans=\"0*m\" data-tans=\"0*m\" data-options=\"3\">0m != 0m; 3</code></td></tr>\n<tr><td><b>ATNumSigFigs_Inaccurate</b></td><td>Slightly inaccurate.</td><td><code class=\"sample\" data-sans=\"10*m\" data-tans=\"11*m\" data-options=\"2\">10m != 11m; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_VeryInaccurate</b></td><td>Very inaccurate.</td><td><code class=\"sample\" data-sans=\"100*m\" data-tans=\"11*m\" data-options=\"2\">100m != 11m; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_WithinRange</b></td><td>Not quite \"strict\" significant-figures, but still accepted.</td><td><code class=\"sample\" data-sans=\"10*m\" data-tans=\"10*m\" data-options=\"2\">10m != 10m; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_WrongSign</b></td><td>Sign error. Note may trigger if either value is zero.</td><td><code class=\"sample\" data-sans=\"-11*m\" data-tans=\"11*m\" data-options=\"2\">-11m != 11m; 2</code></td></tr>\n<tr><td><b>ATUnits_incompatible_units</b></td><td>Wrong unit/dimension</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*mm\" data-options=\"3\">123kg != 123mm; 3</code></td></tr>\n<tr><td><b>ATUnits_correct_numerical</b></td><td>Numerically equivalent, maybe not the correct unit</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*mm\" data-options=\"3\">123kg != 123mm; 3</code></td></tr>\n<tr><td><b>ATUnits_compatible_units</b></td><td>Same dimension/unit, maybe not the same value</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*mg\" data-options=\"3\">123kg != 123mg; 3</code></td></tr>\n<tr><td><b>ATUnits_units_match</b></td><td>Same unit and prefix, maybe not the same value</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*kg\" data-options=\"3\">123kg = 123kg; 3</code></td></tr>\n<tr><td><b>ATUnits_SA_bad_units</b></td><td>The expression is not a number with a unit multiplier possible if the input does not come from units-input</td></tr>\n\n\n\n\n</tbody>\n</table>\n\n\n[[jsxgraph input-ref-anst='anst' input-ref-anss='anss' input-ref-ansoptions='ansoptions'  height='1px']]\n/* JSXGraph blocks allow direct JavaScript access that can be used\n * to do many things, just set the size of the div reserved for the \n * graph that you are not actually building. Or hide it.\n */\n\nvar samples = $('code.sample');\nsamples.on('click', function(e) {\n  // Not .data() as these may look like JSON.\n  var t = $(e.target).attr('data-tans');\n  var s = $(e.target).attr('data-sans');\n  var o = $(e.target).attr('data-options');\n  var sans = $('#' + $.escapeSelector(anss));\n  var tans = $('#' + $.escapeSelector(anst));             \n  var options = $('#' + $.escapeSelector(ansoptions));\n  sans.val(s);\n  tans.val(t);\n  options.val(o);\n  sans.trigger('change');\n  tans.trigger('change');\n  options.trigger('change');\n  sans.trigger('input');\n  tans.trigger('input');\n  options.trigger('input');\n});\n[[/jsxgraph]]\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1*kg",
          "type": "units",
          "guidance-label": "Students answer",
          "validation-box": "val"
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "guidance-label": "Teachers answer",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true
        },
        {
          "name": "ansoptions",
          "tans": "[3,2]",
          "type": "algebraic",
          "guidance-label": "Test options",
          "allow-words": "four,three,two",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATUnitsSigFigs({#%_actual_anss#},{#%_actual_anst#},{#ansoptions#})</code>. However, that would not give the full feedback this test generates.</p>\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_ansoptions and validoptions(ansoptions)\" ]]\n[[ define tr='foo(%_actual_anss,%_actual_anst,ansoptions)'/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "UnitsSigFigs",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Integer",
          "nodes": [
            {
              "name": "The test",
              "test": "UnitsSigFigs",
              "sans": "anss",
              "tans": "anst",
              "options": "ansoptions",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "3-figs  0.000kg = 0kg; 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0,3)*kg",
                      "anst": "0*kg",
                      "ansoptions": "3"
                    }
                  },
                  {
                    "name": "Just 3-digs 0.123mm = 0m; [3,0]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.123,3)*mm",
                      "anst": "stackunits(0,m)",
                      "ansoptions": "[3,0]"
                    }
                  },
                  {
                    "name": "Var-ref 0.1234m = 0.123m; [four, four-1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.1234,4)*m",
                      "anst": "0.123*m",
                      "ansoptions": "RAW:[four, four-1]"
                    }
                  },
                  {
                    "name": "Excessive accuracy 1.10000m = 1.1m; [3,-1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "RAW:1.10000*m",
                      "anst": "1.1*m",
                      "ansoptions": "[3,-1]"
                    }
                  },
                  {
                    "name": "Different prefix",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.00*kg",
                      "anst": "1000*g",
                      "ansoptions": "2"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "3-figs 0.001m != 0m; 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.001,3)*m",
                      "anst": "stackunits(0,m)",
                      "ansoptions": "3"
                    }
                  },
                  {
                    "name": "Just 3-digs 0.12g != 0g; [3,0]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.12,2)*g",
                      "anst": "stackunits(0,g)",
                      "ansoptions": "[3,0]"
                    }
                  },
                  {
                    "name": "Var-ref 0.12345m != 0m; four",
                    "condition": "true",
                    "inputs": {
                      "anss": "0.12345*m",
                      "anst": "stackunits(0,m)",
                      "ansoptions": "RAW:four"
                    }
                  },
                  {
                    "name": "Wrong dimension",
                    "condition": "true",
                    "inputs": {
                      "anss": "11*mg",
                      "anst": "11*mm",
                      "ansoptions": "2"
                    }
                  }
                ]
              }
            },
            {
              "name": "Integer",
              "test": "AlgEquiv",
              "sans": "integerp(ansoptions)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Large enough",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "List",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Large enough",
              "test": "AlgEquiv",
              "sans": "is(ansoptions>0)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "The test",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The option value msut be larger</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "List",
              "test": "AlgEquiv",
              "sans": "listp(ansoptions)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Two element list",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The option must either have an integer value or a list value.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Two element list",
              "test": "AlgEquiv",
              "sans": "length(ansoptions)",
              "tans": "2",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "First element positiveinteger",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The list must have exactly two elements.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "First element positiveinteger",
              "test": "AlgEquiv",
              "sans": "integerp(ansoptions[1]) and is(ansoptions[1]>0)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Second element integer",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The first element of the options list must be an positive integer.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Second element integer",
              "test": "AlgEquiv",
              "sans": "ev(integerp(ansoptions[2]) and is((ansoptions[2] + 2) > 0),simp)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "The test",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The second element of the options list must be an integer.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        }
      ]
    },
    {
      "name": "UnitsStrictSigFigs",
      "description": "All about UnitsStrictSigFigs.",
      "scenevariables": "foo(a,b,c):=ATUnitsSigFigs_CASSigFigsWrapper(a,b,ev(c,simp),stackmap_get(_INPUT_STRING,\"anss\"),true);\nvalidoptions(opts):=ev(\n\tif integerp(opts) then (\n    \tif opts > 0 then true else false\n    ) else if listp(opts) then (\n    \tif length(opts) # 2 then false else (\n        \tif not apply(\"and\", map(integerp, opts)) then false else (\n            \tif opts[1] < 1 then false \n                else if opts[2] < -1 then false,\n                true\n            )\n        )\n    ) else false\n,simp);\n\n/* Provide variables */\nfour:4;\nthree:3;\ntwo:2;",
      "scenetext": "<h3><code>ATUnitsStrictSigFigs(sans,tans,options)</code></h3>\n<p>This is essenttially just the <code>ATUnitsSigFigs(sans,tans,options)</code>-test with the logic of requiring strictly equivalent units i.e. <code>1*m != 100*cm</code>.</p>\n\n<p>A test for checking raw representation of a raw input-value. Only works with <code>sans</code> being a direct reference to an input. This test focuses on checking so called significant-figures. In general one can use this test to just check the existence on significant-figures or at the same time require that sufficient number of them equal to the expected value.</p>\n\n<p>This is essenttially the same test as the <code>ATNumSigFigs</code> however this test includes logic for convertting units and allows the student to use for example milli-meters when the teachers answer is in centi-meters. There is a \"strict\" variant of this test where the units need to match.</p>\n\n<p>The base-test does not use the strict significant-figures rules i.e. for this <code>100</code> has three significant-figures where for strict checks it would have less. There currently does not exist a strict significan-figures test for units.</p>\n\n<p>The answer is expected to be a number followed by the unit, so in this example the <code>sans</code>-input is a units-input. It is not recommended to use more complex input values here.</p>\n\n<p>Note that due to the direct connection to the raw input-value required by this test means that direct calling of this test is not something one can easily do. However, exploring the logic behind the validation message in this question may give a hint on how to do it.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code>, and <code>options</code> and see what happens. Note, for testing purposes the session has the following variables <code>four:4;three:3;two:2</code>, should you want to test certain behaviour.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]], <code>options:</code>[[input:ansoptions]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:UnitsStrictSigFigs]]</p>\n\n<h4>Options</h4>\n<p>This test relies heavily on options. One will need to define either one integer valued option or a list of two integers. The first case is equivalent of giving a list with two equal elements so lets focus on the list form as it is the one that matters:</p>\n<ol>\n<li>The first element (lets call it N) of the list describes how many significant-figures need to be present in the answer. In general one requires an exactly N significant-figures, should one need to allow more to be present then setting the second element to <code>-1</code> will make the test allow N or more. However, in that case all those N+ digits must be correct, to deal with that try setting the teachers asnwer to be the students answer.</li>\n<li>The second element (lets call it M) defines how many of the digits must match the teachers answer, typically one sets <code>M = N - 1</code> to allow some rounding errors in the last digit. Naturally, <code>M &lte; N</code> and both of them are integers.</li>\n</ol>\n\n<h4>Generated feedback</h4>\n<p>The test will give feedback about the number of digits and note about small or large accuracy issues. Depending on your use case you may wish to silence this test and construct your own feedback, using suitable combinations of this test with different options to identify the cases that matter to you. The feedback will additionally note issues with wrong units.</p>\n\n<h4>Classification notes</h4>\n<p>This test will provide plenty of notes about how the answer differs for later statistical analysis, here are some examples, click the samples to see them in action. Most notes are inherited from the underlying <code>ATNumSigFigs.</code>.</p>\n\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th><th>Sample(s)</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATNumSigFigs_WrongDigits</b></td><td>Wrong number of digits.</td><td><code class=\"sample\" data-sans=\"0*m\" data-tans=\"0*m\" data-options=\"3\">0m != 0m; 3</code></td></tr>\n<tr><td><b>ATNumSigFigs_Inaccurate</b></td><td>Slightly inaccurate.</td><td><code class=\"sample\" data-sans=\"10*m\" data-tans=\"11*m\" data-options=\"2\">10m != 11m; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_VeryInaccurate</b></td><td>Very inaccurate.</td><td><code class=\"sample\" data-sans=\"100*m\" data-tans=\"11*m\" data-options=\"2\">100m != 11m; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_WithinRange</b></td><td>Not quite \"strict\" significant-figures, but still accepted.</td><td><code class=\"sample\" data-sans=\"10*m\" data-tans=\"10*m\" data-options=\"2\">10m != 10m; 2</code></td></tr>\n<tr><td><b>ATNumSigFigs_WrongSign</b></td><td>Sign error. Note may trigger if either value is zero.</td><td><code class=\"sample\" data-sans=\"-11*m\" data-tans=\"11*m\" data-options=\"2\">-11m != 11m; 2</code></td></tr>\n<tr><td><b>ATUnits_incompatible_units</b></td><td>Wrong unit/dimension</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*mm\" data-options=\"3\">123kg != 123mm; 3</code></td></tr>\n<tr><td><b>ATUnits_correct_numerical</b></td><td>Numerically equivalent, maybe not the correct unit</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*mm\" data-options=\"3\">123kg != 123mm; 3</code></td></tr>\n<tr><td><b>ATUnits_compatible_units</b></td><td>Same dimension/unit, maybe not the same value</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*mg\" data-options=\"3\">123kg != 123mg; 3</code></td></tr>\n<tr><td><b>ATUnits_units_match</b></td><td>Same unit and prefix, maybe not the same value</td><td><code class=\"sample\" data-sans=\"123kg\" data-tans=\"123*kg\" data-options=\"3\">123kg = 123kg; 3</code></td></tr>\n<tr><td><b>ATUnits_SA_bad_units</b></td><td>The expression is not a number with a unit multiplier possible if the input does not come from units-input</td></tr>\n\n\n\n\n</tbody>\n</table>\n\n\n[[jsxgraph input-ref-anst='anst' input-ref-anss='anss' input-ref-ansoptions='ansoptions'  height='1px']]\n/* JSXGraph blocks allow direct JavaScript access that can be used\n * to do many things, just set the size of the div reserved for the \n * graph that you are not actually building. Or hide it.\n */\n\nvar samples = $('code.sample');\nsamples.on('click', function(e) {\n  // Not .data() as these may look like JSON.\n  var t = $(e.target).attr('data-tans');\n  var s = $(e.target).attr('data-sans');\n  var o = $(e.target).attr('data-options');\n  var sans = $('#' + $.escapeSelector(anss));\n  var tans = $('#' + $.escapeSelector(anst));             \n  var options = $('#' + $.escapeSelector(ansoptions));\n  sans.val(s);\n  tans.val(t);\n  options.val(o);\n  sans.trigger('change');\n  tans.trigger('change');\n  options.trigger('change');\n  sans.trigger('input');\n  tans.trigger('input');\n  options.trigger('input');\n});\n[[/jsxgraph]]\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1*kg",
          "type": "units",
          "guidance-label": "Students answer",
          "validation-box": "val"
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "guidance-label": "Teachers answer",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true
        },
        {
          "name": "ansoptions",
          "tans": "[3,2]",
          "type": "algebraic",
          "guidance-label": "Test options",
          "allow-words": "four,three,two",
          "validation-box": "val",
          "forbid-floats": false,
          "forbid-strings": false,
          "split-number-letter-boundary": false,
          "split-prefixes-from-functions": false,
          "split-implied-variables": false,
          "fix-spaces": true,
          "fix-stars": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back",
          "guidance-label": "back to the test selection"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATUnitsStrictSigFigs({#%_actual_anss#},{#%_actual_anst#},{#ansoptions#})</code>. However, that would not give the full feedback this test generates.</p>\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_ansoptions and validoptions(ansoptions)\" ]]\n[[ define tr='foo(%_actual_anss,%_actual_anst,ansoptions)'/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "UnitsStrictSigFigs",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Integer",
          "nodes": [
            {
              "name": "The test",
              "test": "UnitsStrictSigFigs",
              "sans": "anss",
              "tans": "anst",
              "options": "ansoptions",
              "quiet": false,
              "true": {
                "feedback": "<b>PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "3-figs  0.000kg = 0kg; 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0,3)*kg",
                      "anst": "0*kg",
                      "ansoptions": "3"
                    }
                  },
                  {
                    "name": "Var-ref 0.1234m = 0.123m; [four, four-1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.1234,4)*m",
                      "anst": "0.123*m",
                      "ansoptions": "RAW:[four, four-1]"
                    }
                  },
                  {
                    "name": "Excessive accuracy 1.10000m = 1.1m; [3,-1]",
                    "condition": "true",
                    "inputs": {
                      "anss": "RAW:1.10000*m",
                      "anst": "1.1*m",
                      "ansoptions": "[3,-1]"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "3-figs 0.001m != 0m; 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.001,3)*m",
                      "anst": "stackunits(0,m)",
                      "ansoptions": "3"
                    }
                  },
                  {
                    "name": "Just 3-digs 0.12g != 0g; [3,0]",
                    "condition": "true",
                    "inputs": {
                      "anss": "dispdp(0.12,2)*g",
                      "anst": "stackunits(0,g)",
                      "ansoptions": "[3,0]"
                    }
                  },
                  {
                    "name": "Var-ref 0.12345m != 0m; four",
                    "condition": "true",
                    "inputs": {
                      "anss": "0.12345*m",
                      "anst": "stackunits(0,m)",
                      "ansoptions": "RAW:four"
                    }
                  },
                  {
                    "name": "Wrong dimension",
                    "condition": "true",
                    "inputs": {
                      "anss": "11*mg",
                      "anst": "11*mm",
                      "ansoptions": "2"
                    }
                  },
                  {
                    "name": "Different prefix",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.000*kg",
                      "anst": "1000*g",
                      "ansoptions": "3"
                    }
                  }
                ]
              }
            },
            {
              "name": "Integer",
              "test": "AlgEquiv",
              "sans": "integerp(ansoptions)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Large enough",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "List",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Large enough",
              "test": "AlgEquiv",
              "sans": "is(ansoptions>0)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "The test",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The option value msut be larger</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "List",
              "test": "AlgEquiv",
              "sans": "listp(ansoptions)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Two element list",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The option must either have an integer value or a list value.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Two element list",
              "test": "AlgEquiv",
              "sans": "length(ansoptions)",
              "tans": "2",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "First element positiveinteger",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The list must have exactly two elements.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "First element positiveinteger",
              "test": "AlgEquiv",
              "sans": "integerp(ansoptions[1]) and is(ansoptions[1]>0)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "Second element integer",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The first element of the options list must be an positive integer.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "Second element integer",
              "test": "AlgEquiv",
              "sans": "ev(integerp(ansoptions[2]) and is((ansoptions[2] + 2) > 0),simp)",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "The test",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "<b>The second element of the options list must be an integer.</b>",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        }
      ]
    },
    {
      "name": "ATNumerical",
      "description": "ATNumerical i.e. NumRelative and NumAbsolute",
      "scenevariables": "",
      "scenetext": "<h3><code>ATNumerical(sans,tans,tolerance,\"RELATIVE\"|\"ABSOLUTE\")</code></h3>\n<p>This is a simple numerical tolerance test, it does however provide some logic for dealing with lists and sets which complicates things.</p>\n\n<p>Note that the tests <code>ATNumAbsolute</code> and <code>ATNumRelative</code> are just versions of the same basic test.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code>, and <code>tolerance</code> and see what happens.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]]</p> <code>tolerance:</code>[[input:ansoptions]]</p>\n[[input:testtype]]\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n\n\n<h4>Options</h4>\n<p>The option is now mandatory and describes the tolerance as a single number, in STACK before PRT-compilation the option had a default value of 0.01. The quiet-option is always there.</p>\n\n<h4>Generated feedback</h4>\n<p>These tests provide feedback about the type of the answer and in the case of lists and sets may point out which elements are wrong. When dealing with lists or sets one may need to consider the quiet option.</p>\n\n<h4>Classification notes</h4>\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATNumerical_FAILED</b></td><td>Something failed, probably the wrong type of input, not a number or list or set. Could be a bad <code>tans</code>.</td></tr>\n<tr><td><b>ATNumerical_SA_not_list</b></td><td>A list was being expected.</td></tr>\n<tr><td><b>ATNumerical_SA_not_set</b></td><td>A set was being expected.</td></tr>\n<tr><td><b>ATNumerical_wronglen</b></td><td>Wrong number of elements in the list or set</td></tr>\n<tr><td><b>ATNumerical_wrongentries</b></td><td>The elements that are wrong, also lists the values of the wrong elements.</td></tr>\n</tbody>\n</table>\n\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1",
          "type": "algebraic",
          "forbid-floats": false,
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "forbid-floats": false,
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "ansoptions",
          "tans": "0.01",
          "type": "algebraic",
          "forbid-floats": false,
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "testtype",
          "tans": "\"Relative\"",
          "type": "mcq",
          "mcq-options": [
            {
              "value": "\"ABSOLUTE\"",
              "label": "Absolute-tolerance",
              "group": "correct"
            },
            {
              "value": "\"RELATIVE\"",
              "label": "Relative-tolerance",
              "group": "distractor"
            }
          ],
          "validation-box": "val",
          "mcq-no-deselect": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "[[ if test='%_valid_testtype and is(%_actual_testtype=\"RELATIVE\")' ]]\n<p>These parameters would be equivalent to calling <code>ATNumRelative({#anss#},{#anst#},{#%_actual_ansoptions#})</code></p>\n[[ elif test='%_valid_testtype and is(%_actual_testtype=\"ABSOLUTE\")' ]]\n<p>These parameters would be equivalent to calling <code>ATNumAbsolute({#anss#},{#anst#},{#%_actual_ansoptions#})</code></p>\n[[/if]]\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_ansoptions and numberp(ev(%_actual_ansoptions,simp)) and %_valid_testtype\" ]]\n[[ define tr=\"ATNumerical(anss,anst,ev(%_actual_ansoptions,simp),%_actual_testtype)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Test type",
          "nodes": [
            {
              "name": "Test type",
              "test": "AlgEquiv",
              "sans": "testtype",
              "tans": "\"RELATIVE\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "NumRelative",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "NumAbsolute",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "NumRelative",
              "test": "NumRelative",
              "sans": "anss",
              "tans": "anst",
              "options": "ansoptions",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1=1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.0",
                      "anst": "1.0",
                      "ansoptions": "0.01",
                      "testtype": "\"RELATIVE\""
                    }
                  },
                  {
                    "name": "1.1 = 1.0 +- 0.1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.1",
                      "anst": "1.0",
                      "ansoptions": "0.1",
                      "testtype": "\"RELATIVE\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1.1 != 1.0 +- 0.01",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.1",
                      "anst": "1.0",
                      "ansoptions": "0.01",
                      "testtype": "\"RELATIVE\""
                    }
                  }
                ]
              }
            },
            {
              "name": "NumAbsolute",
              "test": "NumAbsolute",
              "sans": "anss",
              "tans": "anst",
              "options": "ansoptions",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1=1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.0",
                      "anst": "1.0",
                      "ansoptions": "0.01",
                      "testtype": "\"ABSOLUTE\""
                    }
                  },
                  {
                    "name": "1.1 = 1.0 +- 0.1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.1",
                      "anst": "1.0",
                      "ansoptions": "0.1",
                      "testtype": "\"RELATIVE\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1.1 != 1.0 +- 0.01",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.1",
                      "anst": "1.0",
                      "ansoptions": "0.01",
                      "testtype": "\"RELATIVE\""
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "ATUnitsFun",
      "description": "ATUnitsFun relative and absolute tolerances with units with unit conversion or not.",
      "scenevariables": "",
      "scenetext": "<h3><code>ATUnitsRelative(sans,tans,tolerance), \nATUnitsStrictRelative(sans,tans,tolerance), \nATUnitsAbsolute(sans,tans,tolerance), \nATUnitsStrictAbsolute(sans,tans,tolerance)</code></h3>\n\n<p>Numerical tolerance tests for dimensional answers. These tests are a bit odd from the point of view of the tolerances as the tolerances will be interpreted differently depending on whether the units of <code>sans</code> and <code>tans</code> strictly match (same prefixes). If they match the tolerances are in relation to the numerical value of the <code>tans</code> otherwise the tolerance is in relation to the numerical value of the <code>tans</code> after it has been convertted to base SI-units. <i>This complication will make it very inconvenient to use absolute tolerances, unless one ties down the unit-prefixes</i>, it is expected that eventtually new forms of tests are coming where the absolute-tolerances may be given with units and are thus truly absolute and not prefix dependent.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code>, <code>tans</code>, and <code>tolerance</code> and see what happens. Also select if you want strict-units and if you wish to use absolute or relative testing.</p>\n\n<p><code>sans:</code>[[input:anss]], <code>tans:</code>[[input:anst]]</p> <code>tolerance:</code>[[input:tol]]</p>\n[[input:testtype]]\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>The tolerance is a mandatory option, while STACK had a default tolerance Stateful does not. The tolerance is a number or a reference to one.</p>\n\n<h4>Generated feedback</h4>\n<p>There is practically no feedback.</p>\n\n<h4>Classification notes</h4>\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATUnits_units_match</b></td><td>Exact unit-match.</td></tr>\n<tr><td><b>ATUnits_compatible_units</b></td><td>Units represent the same dimensionm can be convertted to equal SI-base-units.</td></tr>\n<tr><td><b>ATUnits_incompatible_units</b></td><td>The units are not representting the same dimension.</td></tr>\n<tr><td><b>ATUnits_correct_numerical</b></td><td>The numerical part matches even when the units are wrong.</td></tr>\n<tr><td><b>ATUnits_SA_no_units</b></td><td>No units present in the students answer, you probably want to use units-inputs to avoid this.</td></tr>\n</tbody>\n</table>\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1*kg",
          "type": "units",
          "validation-box": "val"
        },
        {
          "name": "anst",
          "tans": "1*kg",
          "type": "units",
          "validation-box": "val"
        },
        {
          "name": "tol",
          "tans": "0.01",
          "type": "numerical",
          "validation-box": "val"
        },
        {
          "name": "testtype",
          "tans": "\"ATUnitsRelative\"",
          "type": "mcq",
          "mcq-options": [
            {
              "value": "\"ATUnitsRelative\"",
              "label": "<p>Relative-tolerance, with unit conversion.</p>",
              "group": "correct"
            },
            {
              "value": "\"ATUnitsStrictRelative\"",
              "label": "<p>Relative-tolerance, without unit conversion.</p>",
              "group": "distractor"
            },
            {
              "value": "\"ATUnitsAbsolute\"",
              "label": "<p>Absolute-tolerance, with unit conversion <b>NOTE questionable logic, which is why this should not even be an option</b></p>",
              "group": "distractor",
              "inclusion": "true"
            },
            {
              "value": "\"ATUnitsStrictAbsolute\"",
              "label": "<p>Absolute-tolerance, without unit conversion</p>",
              "group": "distractor",
              "inclusion": "true"
            }
          ],
          "validation-box": "val",
          "mcq-no-deselect": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "[[ if test='%_valid_testtype and is(%_actual_testtype=\"ATUnitsRelative\")' ]]\n<p>These parameters would be equivalent to calling <code>ATUnitsRelative({#%_actual_anss#},{#%_actual_anst#},{#%_actual_tol#})</code></p>\n[[ elif test='%_valid_testtype and is(%_actual_testtype=\"ATUnitsStrictRelative\")' ]]\n<p>These parameters would be equivalent to calling <code>ATUnitsStrictRelative({#%_actual_anss#},{#%_actual_anst#},{#%_actual_tol#})</code></p>\n[[ elif test='%_valid_testtype and is(%_actual_testtype=\"ATUnitsAbsolute\")' ]]\n<p>These parameters would be equivalent to calling <code>ATUnitsAbsolute({#%_actual_anss#},{#%_actual_anst#},{#%_actual_tol#})</code></p>\n[[ elif test='%_valid_testtype and is(%_actual_testtype=\"ATUnitsStrictAbsolute\")' ]]\n<p>These parameters would be equivalent to calling <code>ATUnitsStrictAbsolute({#%_actual_anss#},{#%_actual_anst#},{#%_actual_tol#})</code></p>\n[[/if]]\n\n[[ if test=\"%_valid_anss and %_valid_anst and %_valid_tol and numberp(ev(%_actual_tol,simp)) and %_valid_testtype\" ]]\n[[ if test='is(%_actual_testtype=\"ATUnitsRelative\")']]\n[[ define tr='ATUnitsRelative(%_actual_anss, %_actual_anst, ev(%_actual_tol, simp))'/]]\n[[ elif test='is(%_actual_testtype=\"ATUnitsStrictRelative\")']]\n[[ define tr='ATUnitsStrictRelative(%_actual_anss, %_actual_anst, ev(%_actual_tol, simp))'/]]\n[[ elif test='is(%_actual_testtype=\"ATUnitsAbsolute\")']]\n[[ define tr='ATUnitsAbsolute(%_actual_anss, %_actual_anst, ev(%_actual_tol, simp))'/]]\n[[ elif test='is(%_actual_testtype=\"ATUnitsStrictAbsolute\")']]\n[[ define tr='ATUnitsStrictAbsolute(%_actual_anss, %_actual_anst, ev(%_actual_tol, simp))'/]]\n[[/if]]\n\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]\n\n[[list_errors:anss,anst,tol,testtype]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "no score",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "1",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "0",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "IsRelative",
          "nodes": [
            {
              "name": "IsRelative",
              "test": "StringContains",
              "sans": "testtype",
              "tans": "\"Relative\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "IsStrictRelative",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "IsStrictAbsolute",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "IsStrictRelative",
              "test": "StringContains",
              "sans": "testtype",
              "tans": "\"Strict\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "UnitsStrictRelative",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "UnitsRelative",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "UnitsStrictRelative",
              "test": "UnitsStrictRelative",
              "sans": "anss",
              "tans": "anst",
              "options": "tol",
              "quiet": false,
              "true": {
                "feedback": "<b>StrictRelative: PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Strict Relative 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "0*m/s",
                      "anst": "0*m/s",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsStrictRelative\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>StrictRelative: FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Strict Relative 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "0*m/s",
                      "anst": "0*km/s",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsStrictRelative\""
                    }
                  }
                ]
              }
            },
            {
              "name": "UnitsRelative",
              "test": "UnitsRelative",
              "sans": "anss",
              "tans": "anst",
              "options": "tol",
              "quiet": false,
              "true": {
                "feedback": "<b>Relative: PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Relative 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.1e-6*Mg",
                      "anst": "1.2*kN*ns/(mm*Hz)",
                      "tol": "0.15",
                      "testtype": "\"ATUnitsRelative\""
                    }
                  },
                  {
                    "name": "Relative 3 matching dimension",
                    "condition": "true",
                    "inputs": {
                      "anss": "0.0*m",
                      "anst": "0.0*km",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsRelative\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>Relative: FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Relative 2",
                    "condition": "true",
                    "inputs": {
                      "anss": "1.1e-6*Mg",
                      "anst": "1.2*kN*ns/(mm*Hz)",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsRelative\""
                    }
                  },
                  {
                    "name": "Relative 4 mismatched dimension",
                    "condition": "true",
                    "inputs": {
                      "anss": "0.0*m",
                      "anst": "0.0*m/s",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsRelative\""
                    }
                  }
                ]
              }
            },
            {
              "name": "IsStrictAbsolute",
              "test": "StringContains",
              "sans": "testtype",
              "tans": "\"Strict\"",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "UnitsStrictAbsolute",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "next": "UnitsAbsolute",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "UnitsStrictAbsolute",
              "test": "UnitsStrictAbsolute",
              "sans": "anss",
              "tans": "anst",
              "options": "tol",
              "quiet": false,
              "true": {
                "feedback": "<b>StrictAbsolute: PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Strict Absolute 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1*m",
                      "anst": "1*m",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsStrictAbsolute\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>StrictAbsolute: FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            },
            {
              "name": "UnitsAbsolute",
              "test": "UnitsAbsolute",
              "sans": "anss",
              "tans": "anst",
              "options": "tol",
              "quiet": false,
              "true": {
                "feedback": "<b>Absolute: PASS</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "Ansolute 1",
                    "condition": "true",
                    "inputs": {
                      "anss": "1*m",
                      "anst": "1*m",
                      "tol": "0.01",
                      "testtype": "\"ATUnitsAbsolute\""
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<b>Absolute: FAIL</b>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        }
      ]
    },
    {
      "name": "LowestTerms",
      "description": "A test that looks for fractions in the answer and complains is any of them are not fully \"simplified\"",
      "scenevariables": "",
      "scenetext": "<h3><code>ATLowestTerms(sans,noop)</code></h3>\n<p>This is a test of the form of the answer. It compares the answer agains nothing but goes though all the fractions and check that there are no common factors that could have been eliminated. For historical reason the raw-test takes two values but does nothing with the latter.</p>\n\n<p>The test will also care about powers, especially frcational powers, present in the denominator as well as imaginary-values in denominator.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code> and see what happens</p>\n\n<p><code>sans:</code>[[input:anss]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>The only option is to silence the test.</p>\n\n<h4>Generated feedback</h4>\n<p>The test will point out the fractions that could be further simplified.</p>\n\n<h4>Classification notes</h4>\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATLowestTerms_entries</b></td><td>There are terms to simplify.</td></tr>\n<tr><td><b>ATLowestTerms_not_rat</b></td><td>There exists a fractional power in some denominator.</td></tr>\n</tbody>\n</table>\n\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "2/4",
          "type": "algebraic",
          "forbid-floats": false,
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATLowestTerms({#anss#},0)</code></p>\n\n[[ if test=\"%_valid_anss\" ]]\n[[ define tr=\"ATLowestTerms(anss,0)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "The test",
          "nodes": [
            {
              "name": "The test",
              "test": "LowestTerms",
              "sans": "anss",
              "tans": "",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<p><b>PASS</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1/2",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/2"
                    }
                  },
                  {
                    "name": "1/2+1/3",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/2+1/3"
                    }
                  },
                  {
                    "name": "sqrt(2)/3",
                    "condition": "true",
                    "inputs": {
                      "anss": "sqrt(2)/3"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<p><b>FAIL</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "2/4",
                    "condition": "true",
                    "inputs": {
                      "anss": "2/4"
                    }
                  },
                  {
                    "name": "1/2+2/4",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/2+2/4"
                    }
                  },
                  {
                    "name": "1/sqrt(2)",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/sqrt(2)"
                    }
                  },
                  {
                    "name": "cos(3/6*x)",
                    "condition": "true",
                    "inputs": {
                      "anss": "cos(3/6*x)"
                    }
                  },
                  {
                    "name": "3/9=x",
                    "condition": "true",
                    "inputs": {
                      "anss": "3/9=x"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "ATGT(E)",
      "description": "Simple numerical separation tests",
      "scenevariables": "",
      "scenetext": "<h3><code>ATGT(sans,tans)</code> and <code>ATGTE(sans,tans)</code></h3>\n<p>These tests are intended to divide the search space by a numerical value. The values compared need to evaluate to numbers for the tests to work.</p>\n\n<p> There are no LT and LTE tests as it is assumed that the author can swap the <code>sans</code> and <code>tans</code> accordingly.</p>\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code> and <code>tans</code> and see what happens</p>\n\n<p><code>sans:</code>[[input:anss]] <code>tans:</code>[[input:anst]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:gt]]</p>\n<p>[[feedback:gte]]</p>\n\n<h4>Options</h4>\n<p>The only option is to silence the test.</p>\n\n<h4>Generated feedback</h4>\n<p>This test gives no feedback.</p>\n\n<h4>Classification notes</h4>\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATGT_false</b></td><td>When the GT-test does not pass.</td></tr>\n<tr><td><b>ATGT_true</b></td><td>When it passes.</td></tr>\n<tr><td><b>ATGTE_false</b></td><td>When the GTE-test does not pass.</td></tr>\n<tr><td><b>ATGTE_true</b></td><td>When it passes.</td></tr>\n<tr><td><b>Not number</b></td><td>If the values are not numbers.</td></tr>\n</tbody>\n</table>\n\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "1",
          "type": "algebraic",
          "forbid-floats": false,
          "validation-box": "val"
        },
        {
          "name": "anst",
          "tans": "1",
          "type": "algebraic",
          "forbid-floats": false,
          "validation-box": "val"
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATGT({#%_actual_anss#},{#%_actual_anst#})</code> or <code>ATGTE({#%_actual_anss#},{#%_actual_anst#})</code></p>\n\n<h4><code>ATGT</code></h4>\n[[ if test=\"%_valid_anss and %_valid_anst\" ]]\n[[ define tr=\"ATGT(%_actual_anss,%_actual_anst)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]\n\n<h4><code>ATGTE</code></h4>\n[[ if test=\"%_valid_anss and %_valid_anst\" ]]\n[[ define tr=\"ATGTE(%_actual_anss,%_actual_anst)\"/]]<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "gt",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "ATGT",
          "nodes": [
            {
              "name": "ATGT",
              "test": "GT",
              "sans": "anss",
              "tans": "anst",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<p><b>GT:PASS</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1/2 > 1/3",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/2",
                      "anst": "1/3"
                    }
                  },
                  {
                    "name": "pi > 3",
                    "condition": "true",
                    "inputs": {
                      "anss": "pi",
                      "anst": "3"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<p><b>GT:FAIL</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1/3 <= 1/2",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/3",
                      "anst": "1/2"
                    }
                  },
                  {
                    "name": "x <= 5",
                    "condition": "true",
                    "inputs": {
                      "anss": "x",
                      "anst": "5"
                    }
                  }
                ]
              }
            }
          ]
        },
        {
          "name": "gte",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "ATGTE",
          "nodes": [
            {
              "name": "ATGTE",
              "test": "GTE",
              "sans": "anss",
              "tans": "anst",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<p><b>GTE:PASS</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1/2 >= 1/3",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/2",
                      "anst": "1/3"
                    }
                  },
                  {
                    "name": "1/2 >= 2/4",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/2",
                      "anst": "2/4"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<p><b>GTE:FAIL</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "1/3 < 1/2",
                    "condition": "true",
                    "inputs": {
                      "anss": "1/3",
                      "anst": "1/2"
                    }
                  },
                  {
                    "name": "3 <= pi",
                    "condition": "true",
                    "inputs": {
                      "anss": "3",
                      "anst": "pi"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "name": "Expanded",
      "description": "Is the expression fully expanded, i.e. are here any parentheses.",
      "scenevariables": "",
      "scenetext": "<h3><code>ATExpanded(sans,noop)</code></h3>\n<p>This is a test of the form of the answer. It checks that the expression is fully expanded and contains no parenthesis that could be removed. For historical reason the raw-test takes two values but does nothing with the latter.</p>\n\n\n<h4>Direct test</h4>\n<p>Fill in the <code>sans</code> and see what happens</p>\n\n<p><code>sans:</code>[[input:anss]]</p>\n<p>[[validation:val]]</p>\n<p>[[feedback:primary]]</p>\n\n<h4>Options</h4>\n<p>The only option is to silence the test.</p>\n\n<h4>Generated feedback</h4>\n<p>The test will tell if the answer is not an expression, i.e. if an equality is being given.</p>\n\n<h4>Classification notes</h4>\n<table>\n<thead>\n<tr><th>Token</th><th>General description</th></tr>\n</thead>\n<tbody>\n<tr><td><b>ATExpanded_TRUE</b></td><td>The expression is fully expanded.</td></tr>\n<tr><td><b>ATExpanded_FALSE</b></td><td>There exists somethign to expand.</td></tr><tr><td><b>ATExpanded_SA_not_expression</b></td><td>The answer was not an expression.</td></tr>\n</tbody>\n</table>\n\n\n\n<p>[[input:back]][[feedback:back]]</p>",
      "inputs": [
        {
          "name": "anss",
          "tans": "x*(2+x)",
          "type": "algebraic",
          "validation-box": "val",
          "no-units": true
        },
        {
          "name": "back",
          "type": "button",
          "input-label": "Back"
        }
      ],
      "vboxes": [
        {
          "name": "val",
          "type": "custom",
          "text": "<p>These parameters would be equivalent to calling <code>ATExpanded({#anss#},0)</code></p>\n\n[[ if test=\"%_valid_anss\" ]]\n[[ define tr=\"ATExpanded(anss,0)\"/]]\n<p>The test would\n[[ if test=\"tr[2]\"]]\npass,\n[[else]]\nfail,\n[[/if]]\n[[ if test='is(tr[3]=\"\")']]\nthere would be no notes,\n[[else]]\nit would return specific notes <code>{@tr[3]@}</code>,\n[[/if]]\n[[ if test='is(tr[4]=\"\")']]\nand no feedback.\n[[else]]\nand some feedback to see it press 'Check'.\n[[/if]]\n</p>\n[[/ if ]]"
        }
      ],
      "prts": [
        {
          "name": "back",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "Root node",
          "nodes": [
            {
              "name": "Root node",
              "test": "AlgEquiv",
              "sans": "back",
              "tans": "true",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "",
                "variables": "",
                "next": "$SCENE:entry",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              },
              "false": {
                "feedback": "",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": []
              }
            }
          ]
        },
        {
          "name": "primary",
          "feedbackvariables": "",
          "scoremode": "best",
          "scoremodeparameters": "",
          "value": 1,
          "root": "The test",
          "nodes": [
            {
              "name": "The test",
              "test": "Expanded",
              "sans": "anss",
              "tans": "",
              "options": "",
              "quiet": false,
              "true": {
                "feedback": "<p><b>PASS</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "x*2+x",
                    "condition": "true",
                    "inputs": {
                      "anss": "x*2+x"
                    }
                  },
                  {
                    "name": "3+2*sqrt(3)",
                    "condition": "true",
                    "inputs": {
                      "anss": "3+2*sqrt(3)"
                    }
                  }
                ]
              },
              "false": {
                "feedback": "<p><b>FAIL</b></p>",
                "variables": "",
                "scoremode": "=",
                "score": "",
                "penaltymode": "=",
                "penalty": "",
                "tests": [
                  {
                    "name": "x*(x+1)",
                    "condition": "true",
                    "inputs": {
                      "anss": "x*(x+1)"
                    }
                  },
                  {
                    "name": "x^2-(a+b)*x+a*b",
                    "condition": "true",
                    "inputs": {
                      "anss": "x^2-(a+b)*x+a*b"
                    }
                  }
                ]
              }
            }
          ]
        }
      ]
    }
  ],
  "entryscenename": "entry",
  "options": {
    "assumepositive": false,
    "assumereal": false,
    "complexno": "i",
    "multiplicationsign": "dot",
    "sqrtsign": true,
    "inversetrig": "cos-1",
    "matrixparens": "[",
    "questionsimplify": true
  },
  "meta": {
    "statevariablenumbers": [],
    "simulation": {
      "seeds": [
        "4"
      ]
    }
  },
  "variants": {
    "_set": "",
    "A": [],
    "B": [],
    "C": []
  }
}